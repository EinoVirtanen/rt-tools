/*
 * Copyright (c) 2013,2014 by Enea Software AB
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Enea Software AB nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <getopt.h>
#include <stdio.h>
#include <stdlib.h>

#include "partrt.h"
#include "config.h"

const char *appname;

extern int option_debug;
extern int option_verbose;

const char *nrt_partition = "nrt";
const char *rt_partition = "rt";

static void usage(void)
{
	puts("partrt - Create real time CPU partitions on SMP Linux\n"
	     "Usage:\n"
	     "partrt [options] <cmd>\n"
	     "partrt [options] create [cmd-options] [cpumask]\n"
	     "partrt [options] undo [cmd-options]\n"
	     "partrt [options] run [cmd-options] <partition> <command>\n"
	     "partrt [options] move [cmd-options] <pid> <partition>\n"
	     "partrt [options] list [cmd-options]\n"
	     "\n"
	     "Each sub-command above can be followed by '-h' for more information about that\n"
	     "sub-command.\n"
	     "\n"
	     "The purpose of partrt is to administrate CPU partitions/domains with different\n"
	     "requirements on OS jitter and real-time performance. partrt requires that the\n"
	     "Linux kernel supports SMP and cpusets. Please see the Linux cpuset\n"
	     "documentation for more information.\n"
	     "\n"
	     "When the 'create' sub-command is given, a real time partition and a non-real\n"
	     "time partition will be created. Then partrt will try to move all tasks into the\n"
	     "non-real time partition. Some kernel threads have an affinity requirement that\n"
	     "prohibits such a move, these will be left in the cpuset root.\n"
	     "\n"
	     "Read more about reducing OS jitter in the Linux kernel documentation:\n"
	     "https://www.kernel.org/doc/Documentation/kernel-per-CPU-kthreads.txt\n"
	     "\n"
	     "Options:\n"
	     "-v           Produce informational message to stderr\n"
	     "-V           Show version information and exit.\n"
	     "-x           Trace script execution\n"
	     "-r NAME      Name the real time partition 'NAME'\n"
	     "             (default: $DEFAULT_RT_PARTITION)\n"
	     "-n NAME      Name the non-real time partition 'NAME'\n"
	     "             (default: $DEFAULT_NRT_PARTITION)\n"
	     "\n"
	     "Example:\n"
	     "        Create RT partition on CPU 2 and 3:"
	     "        > partrt create 0xc\n"
	     "\n"
	     "        Run cyclictest on CPU 3 in the RT partition:\n"
	     "        > partrt run -c 0x8 rt cyclictest -n -i 10000 -l 10000\n"
	     "\n"
	     "        Move cyclictest to NRT partition:\n"
	     "        > partrt move 'pid of cyclictest' nrt\n"
	     "\n"
	     "        Undo partitioning (restore environment)\n"
	     "        > partrt undo\n"
		);

	exit(0);
}

static void version(void)
{
	printf("partrt %d.%d\n"
		"\n"
		"Copyright (C) 2013,2014 by Enea Software AB.\n",
		partrt_VERSION_MAJOR, partrt_VERSION_MINOR
		);

	exit(0);
}

static void usage_undo(void)
{
	puts("partrt [options] undo [cmd-options]\n"
	     "\n"
	     "Undo what the 'create' command does. Will put all tasks in the root\n"
	     "cpuset and change the IRQ affinities to include all CPUs.\n"
	     "\n"
	     "cmd-options:\n"
	     "-h           Show this help text and exit.\n"
	     "-s file      File containing environment configuration to be\n"
	     "             loaded. The configuration file is normally\n"
	     "             generated by the 'create' sub-command\n"
	     "             (/tmp/partrt_env). If no file is provided, partrt\n"
	     "             will use default values for the environment.\n"
		);
}

static void usage_run(void)
{
	puts("partrt [options] move [cmd-options] <pid> <partition>\n"
	     "\n"
	     "partrt [options] run [cmd-options] <partition> <command>\n"
	     "\n"
	     "Run <command> with <options> on <partition>\n"
	     "where <partition> is expressed as a CPUSET directory\n"
	     "relative to CPUSET root.\n"
	     "\n"
	     "<partition>: Name of partition to execute within.\n"
	     "\n"
	     "cmd-options:\n"
	     "-c <cpumask>  Run task on hexadecimal <cpumask>. <cpumask> should\n"
	     "              include a subset of the CPUs of the selected partition.\n"
	     "-f <prio>     Use SCHED_FIFO with RT priority <prio>\n"
	     "-h            Show this help text and exit.\n"
	     "-o            Use SCHED_OTHER\n"
	     "-r <prio>     Use SCHED_RR with RT priority <prio>\n"
		);

	exit(0);
}

static void usage_move(void)
{
	puts("partrt [options] move [cmd-options] <pid> <partition>\n"
	     "\n"
	     "Changes the affinity of task <pid> to <cpumask>. Will automatically put\n"
	     "the task in the correct partition. The command will fail if <cpumask>\n"
	     "intersects with multiple partitions.\n"
	     "\n"
	     "<pid>: PID of task to be moved\n"
	     "\n"
	     "<partition>: Name of the partition that the task should be moved to\n"
	     "\n"
	     "cmd-options:\n"
	     "-c <cpumask>  Run task on hexadecimal <cpumask>. <cpumask> should\n"
	     "              include a subset of the CPUs of the selected partition.\n"
	     "-h            Show this help text and exit.\n"
		);

	exit(0);
}

static void usage_list(void)
{
	puts("partrt [options] list\n"
	     "Display current partitions\n");

	exit(0);
}

unsigned long long option_to_ul(const char *str, unsigned long min,
				unsigned long max, const char *errprefix)
{
	char *endptr;
	const unsigned long long val = strtoull(str, &endptr, 0);

	if (*str == '\0')
		fail("%s: Expected integer, but got nothing\n", errprefix);

	if (*endptr != '\0')
		fail("%s: %s: Mal-formed interger value\n", errprefix, str);

	if (val < min)
		fail("%s: Value %llu too small, must not be smaller than %llu\n",
		     errprefix, val, min);

	if (val > max)
		fail("%s: Value %llu too large, must not be larger thn %llu\n",
		     errprefix, val, max);

	return val;
}

int cmd_undo(int argc, char *argv[])
{
}

int cmd_run(int argc, char *argv[])
{
}

int cmd_move(int argc, char *argv[])
{
}

int cmd_list(int argc, char *argv[])
{
}



int main(int argc, char *argv[])
{
	static const struct option long_options[] = {
		{ "help",    no_argument,       NULL, 'h' },
		{ "nrt",     required_argument, NULL, 'n' },
		{ "rt",      required_argument, NULL, 'r' },
		{ "verbose", no_argument,       NULL, 'v' },
		{ "version", no_argument,       NULL, 'V' },
		{ "debug",   no_argument,       NULL, 'x' },
		{ NULL,      0,                 NULL, '\0'}
	};
	static const char short_options[] = "+hn:r:vVx";
	static const struct {
		const char *name;
		int (*func)(int, char **);
	} commands[] = {
		{ "create", cmd_create },
		{ "undo",   cmd_undo   },
		{ "run",    cmd_run    },
		{ "move",   cmd_move   },
		{ "list",   cmd_list   }
	};
	size_t idx;
	int c;

	while ((c = getopt_long(argc, argv, short_options, long_options,
				NULL)) != -1) {
		switch(c) {
		case 'h':
			usage();
		case 'V':
			version();
		case 'n':
			nrt_partition = optarg;
			break;
		case 'r':
			rt_partition = optarg;
			break;
		case 'v':
			option_verbose = 1;
			break;
		case 'x':
			option_debug = 1;
			break;
		case '?':
			exit(1);
		default:
			fail("Internal error: '-%c': Switch accepted but not implemented\n",
				c);
		}
	}

	if (optind >= argc) {
		fail("No command gived, nothing to do. Use --help for syntax.\n");
	}

	for (idx = 0; idx < (sizeof (commands) / sizeof (*commands)); idx++) {
		if (strcmp(commands[idx].name, argv[optind]) == 0) {
			optind++;
			return commands[idx].func(argc, argv);
		}
	}

	fail("%s: Unknown command. Use --help for syntax.\n", argv[optind]);
}
